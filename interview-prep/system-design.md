# 系统设计题

基于 NexusNote 项目的系统设计面试题集合。

---

## �� 目录

- [设计原则](#设计原则)
- [智能访谈引擎](#智能访谈引擎)
- [RAG 检索系统](#rag-检索系统)
- [实时协作编辑](#实时协作编辑)
- [AI 代理系统](#ai-代理系统)
- [多租户隔离](#多租户隔离)

---

## 设计原则

### 问题 1：系统设计面试框架

**Q: 请描述你进行系统设计的一般步骤？**

**A:**

1. **需求理解与澄清**
   - 功能需求：系统要做什么
   - 非功能需求：性能、可用性、一致性、扩展性
   - 约束条件：技术栈、成本、时间

2. **高层设计**
   - 画系统架构图
   - 识别核心组件
   - 定义组件间交互

3. **详细设计**
   - 数据库 schema 设计
   - API 设计
   - 关键算法选择

4. **瓶颈识别与优化**
   - 性能瓶颈
   - 单点故障
   - 扩展性问题

5. **权衡分析**
   - CAP 理论
   - 一致性 vs 可用性
   - 成本 vs 性能

---

## 智能访谈引擎

### 问题 2：设计 NexusNote 的智能访谈引擎

**Q: 请设计一个智能访谈引擎，通过自然对话了解用户需求，生成个性化学习路径。**

**A:**

#### 1. 需求分析

**功能需求：**
- 用户输入自然语言描述学习目标
- AI 主动提问收集缺失信息
- 用户可以选择预定义选项或自由输入
- 实时更新用户画像
- 生成完整的课程大纲
- 支持用户调整和确认

**非功能需求：**
- 响应时间 < 2s
- 高可用性（99.9%）
- 支持并发 1000+ 用户
- 会话状态持久化

#### 2. 高层架构

```
┌─────────────────────────────────────────────────────────────┐
│                         用户界面层                              │
│  ┌──────────────────┐  ┌──────────────────┐                 │
│  │  访谈对话界面     │  │  大纲确认界面     │                 │
│  └──────────────────┘  └──────────────────┘                 │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        API 网关层                              │
│  ┌────────────────────────────────────────────────────────┐  │
│  │  /api/chat (统一入口，根据 explicitIntent 路由)         │  │
│  └────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        ▼                     ▼                     ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│  访谈代理      │   │  聊天代理      │   │  其他代理      │
│  (Interview)  │   │   (Chat)      │   │               │
└───────────────┘   └───────────────┘   └───────────────┘
        │                     │
        ▼                     ▼
┌─────────────────────────────────────────────────────────────┐
│                      工具层 (Tools)                           │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────┐ │
│  │ updateProfile   │ │ suggestOptions  │ │proposeOutline│ │
│  └─────────────────┘ └─────────────────┘ └─────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        数据层                                 │
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │ course_profiles  │  │  users           │                │
│  └──────────────────┘  └──────────────────┘                │
└─────────────────────────────────────────────────────────────┘
```

#### 3. 数据库设计

**course_profiles 表：**
```sql
CREATE TABLE course_profiles (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  title TEXT,
  description TEXT,
  difficulty TEXT,
  estimated_minutes INTEGER,
  outline_data JSONB,
  outline_markdown TEXT,
  design_reason TEXT,
  interview_profile JSONB,
  interview_messages JSONB,
  interview_status TEXT,
  current_chapter INTEGER,
  current_section INTEGER,
  is_completed BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

**索引设计：**
- `user_id` 索引（查询用户的所有课程）
- `interview_status` 索引（筛选进行中的访谈）
- `created_at` 索引（排序）

#### 4. 核心流程

**访谈流程：**
1. 用户访问 `/create?goal=xxx`
2. 前端初始化 `useInterview` hook
3. `useInterview` 使用 `DefaultChatTransport` 配置
4. 发送第一条消息，携带 `explicitIntent: "INTERVIEW"` 和 `initialGoal`
5. 后端根据 `explicitIntent` 路由到访谈代理
6. 访谈代理使用 `ToolLoopAgent` 执行工具
7. 工具返回结果，前端动态渲染 UI
8. 用户交互后，通过 `addToolOutput` 继续流程
9. 最终生成完整课程大纲

#### 5. 关键技术决策

**会话管理：**
- 使用响应头 `X-Session-Id` 返回 sessionId
- 前端存储 sessionId，后续请求自动携带
- 后端通过 sessionId 恢复会话状态

**参数传递：**
- 使用 `DefaultChatTransport` 的 `body` 函数动态注入参数
- 避免每次 `sendMessage` 手动传参
- 确保 `explicitIntent`、`sessionId`、`initialGoal` 正确传递

**工具调用：**
- 区分客户端工具和服务端工具
- 客户端工具暂停代理循环，等待用户输入
- 使用 `addToolOutput` 时必须传入 `tool` 参数
- 设置 `sendAutomaticallyWhen` 实现自动请求触发

#### 6. 扩展性考虑

**水平扩展：**
- API 网关层无状态，可以水平扩展
- 使用 Redis 缓存会话状态
- 数据库读写分离

**AI 能力扩展：**
- 支持多模型（GPT-4、Claude、Gemini）
- 模型路由和降级策略
- Prompt 版本管理

---

## RAG 检索系统

### 问题 3：设计 RAG 检索增强生成系统

**Q: 请设计一个 RAG 系统，用于从用户文档中检索相关信息，增强 AI 回答。**

**A:**

#### 1. 需求分析

**功能需求：**
- 文档分块和向量化
- 混合搜索（关键词 + 向量）
- 查询重写
- 相关文档 rerank
- 上下文组装

**非功能需求：**
- 检索延迟 < 500ms
- 支持百万级文档
- 检索准确率 > 85%

#### 2. 系统架构

```
┌─────────────────┐
│   用户查询      │
└────────┬────────┘
         │
         ▼
┌──────────────────────────────┐
│   查询重写 (Query Rewriter)  │
│  - 消除歧义                   │
│  - 扩展查询                   │
│  - 多轮对话上下文             │
└────────┬─────────────────────┘
         │
         ▼
┌──────────────────────────────┐
│      混合检索 (Hybrid)       │
│  ┌────────────┐ ┌──────────┐│
│  │ 向量检索   │ │关键词检索 ││
│  │ (pgvector) │ │(tsvector)││
│  └────────────┘ └──────────┘│
└────────┬─────────────────────┘
         │
         ▼
┌──────────────────────────────┐
│      重排序 (Rerank)         │
│  - 交叉编码器                 │
│  - 融合多个检索结果           │
└────────┬─────────────────────┘
         │
         ▼
┌──────────────────────────────┐
│    上下文组装 (Context)       │
│  - 选择 Top-K 文档            │
│  - 格式化为提示词             │
└────────┬─────────────────────┘
         │
         ▼
┌──────────────────────────────┐
│      LLM 生成回答             │
└──────────────────────────────┘
```

#### 3. 数据库设计

**document_chunks 表：**
```sql
CREATE TABLE document_chunks (
  id UUID PRIMARY KEY,
  document_id UUID REFERENCES documents(id),
  chunk_index INTEGER,
  content TEXT,
  embedding halfvec(4000),
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 向量索引 (HNSW)
CREATE INDEX ON document_chunks USING hnsw (embedding halfvec_ip_ops);

-- GIN 索引用于全文搜索
CREATE INDEX ON document_chunks USING GIN (to_tsvector('english', content));
```

#### 4. 向量选择

**为什么用 halfvec(4000)？**
- 节省 50% 存储空间
- 对于大多数应用，精度损失可接受
- 4000 维足够捕获语义信息

**备选方案：**
- `vec(4000)`: 全精度，占用双倍空间
- `bit(4000)`: 二值化，更快但精度更低

---

## 实时协作编辑

### 问题 4：设计实时协作编辑系统

**Q: 请设计一个支持多人实时协作的富文本编辑器系统。**

**A:**

#### 1. 需求分析

**功能需求：**
- 多人同时编辑同一文档
- 实时同步编辑操作
- 显示其他用户的光标位置
- 冲突自动解决
- 文档版本历史
- 离线编辑和同步

**非功能需求：**
- 同步延迟 < 100ms
- 支持 100+ 并发用户
- 最终一致性保证

#### 2. 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                      客户端 (Tiptap)                         │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Y.js Document (CRDT)                                   │ │
│  │  - 本地状态管理                                          │ │
│  │  - 操作转换                                             │ │
│  └────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  PartySocket (WebSocket)                                │ │
│  │  - 与 PartyKit 服务器通信                                │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   PartyKit Server                            │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  Hocuspocus (Y.js 服务器)                              │ │
│  │  - 文档同步                                             │ │
│  │  - 感知层 (Awareness)                                   │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        持久化层                               │
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │  PostgreSQL      │  │  Redis (缓存)    │                │
│  └──────────────────┘  └──────────────────┘                │
└─────────────────────────────────────────────────────────────┘
```

#### 3. 核心技术选择

**CRDT vs OT:**
- **CRDT** (Conflict-free Replicated Data Type)
  - 优点：无需中央协调、离线支持好、实现相对简单
  - 缺点：文档体积可能增长
  - 选择：Y.js 实现的 CRDT

**OT** (Operational Transformation)
- 优点：文档体积小
- 缺点：实现复杂、需要中央服务器

#### 4. 数据同步流程

1. 用户在本地编辑文档
2. Y.js 生成操作（Operation）
3. 通过 WebSocket 发送到 PartyKit 服务器
4. Hocuspocus 广播操作给其他客户端
5. 其他客户端应用操作到本地文档
6. 定期将文档快照保存到 PostgreSQL

---

## AI 代理系统

### 问题 5：设计 AI 代理系统

**Q: 请设计一个支持多 Agent 协作的系统。**

**A:**

（待补充）

---

## 多租户隔离

### 问题 6：设计多租户系统

**Q: 请设计一个支持多租户的 SaaS 系统，确保租户间数据隔离。**

**A:**

（待补充）

---

## 💡 系统设计面试技巧

1. **先澄清需求**：不要急于设计，先问清楚所有需求
2. **画架构图**：用简单的框图展示高层设计
3. **从简到繁**：先设计简单版本，再逐步优化
4. **讨论权衡**：每个决策都要说明为什么这样选
5. **识别瓶颈**：主动指出可能的性能瓶颈和解决方案
6. **数据先行**：先设计数据库 schema，再考虑 API

---

## 📚 推荐资源

- [System Design Primer](https://github.com/donnemartin/system-design-primer)
- [Designing Data-Intensive Applications](https://dataintensive.net)
- [AWS Architecture Center](https://aws.amazon.com/architecture)
- [Google Cloud Architecture Framework](https://cloud.google.com/architecture/framework)
EOF~